config DEFCONFIG_LIST
	string
	option defconfig_list
	default ARCH_DEFCONFIG
	default "arch/$(ARCH)/defconfig"

config GREGORIAN_CALENDER
	bool

config HAS_KALLSYMS
	bool

config HAS_MODULES
	bool

config HAS_CACHE
	bool
	help
	  This allows you do run "make ARCH=sandbox allyesconfig".

	  Drivers that depend on a cache implementation can depend on this
	  config, so that you don't get a compilation error.

config HAS_DMA
	bool
	help
	  This allows you do run "make ARCH=sandbox allyesconfig".

	  Drivers that depend on a DMA implementation can depend on this
	  config, so that you don't get a compilation error.

config GENERIC_GPIO
	bool

config BLOCK
	bool

config BLOCK_WRITE
	bool

config ELF
	bool
	depends on MIPS

config FILETYPE
	bool

config BINFMT
	bool
	select FILETYPE

config UIMAGE
	select UNCOMPRESS
	select CRC32
	bool

config FITIMAGE
	bool
	select OFTREE
	select DIGEST

config FITIMAGE_SIGNATURE
	select CRYPTO_RSA
	bool

config LOGBUF
	bool

config STDDEV
	bool

config BAREBOX_UPDATE
	bool

config MENUTREE
	bool
	select GLOB
	select GLOB_SORT

config EFI_GUID
	bool
	help
	  With this option a table of EFI guids is compiled in.

config EFI_DEVICEPATH
	bool

config FILE_LIST
	bool

config ARCH_DMA_ADDR_T_64BIT
	bool

config BAREBOX_UPDATE_IMX_NAND_FCB
	bool
	depends on ARCH_IMX6 || ARCH_IMX28
	depends on BAREBOX_UPDATE
	depends on MTD_WRITE
	depends on NAND_MXS
	select BCH if ARCH_IMX6
	default y

config UBIFORMAT
	bool
	select LIBSCAN
	select LIBUBIGEN
	depends on MTD_UBI
	default y

config USBGADGET_START
	bool
	depends on CMD_USBGADGET || USB_GADGET_AUTOSTART
	select ENVIRONMENT_VARIABLES
	select FILE_LIST
	default y

config BOOT
	bool

menu "General Settings"

config LOCALVERSION
	string "Local version - append to the version string"
	help
	  Append an extra string to the end of your version string.
	  The string you set here will be appended after the contents of
	  any files with a filename matching localversion* in your
	  object and source tree, in that order. Your total string can
	  be a maximum of 64 characters.

config LOCALVERSION_AUTO
	bool "Automatically append version information to the version string"
	default y
	help
	  This will try to automatically determine if the current tree is a
	  release tree by looking for git tags that belong to the current
	  top of tree revision.

	  A string of the format -gxxxxxxxx will be added to the localversion
	  if a git-based tree is found. The string generated by this will be
	  appended after any matching localversion* files, and after the value
	  set in CONFIG_LOCALVERSION.

	  (The actual string used here is the first eight characters produced
	  by running the command:

	    $ git rev-parse --verify HEAD

	  which is done within the script "scripts/setlocalversion".)

config BOARDINFO
	string

config BANNER
	bool "display banner"
	default y

config MEMINFO
	bool "display memory info"
	default y

config ENVIRONMENT_VARIABLES
	bool "environment variables support"

config GLOBALVAR
	bool "global environment variables support"
	default y if !SHELL_NONE
	select FNMATCH
	help
	  Global environment variables begin with "global.". Unlike normal
	  shell variables they have the same values in all contexts. Global
	  variables are used to control several aspects of the system behaviour.
	  If unsure, say yes here.

config NVVAR
	bool "Non volatile global environment variables support"
	default y if !SHELL_NONE
	depends on GLOBALVAR
	depends on ENV_HANDLING
	select FNMATCH
	help
	  Non volatile environment variables begin with "nv.". They behave like
	  global variables above, but their values are saved in the environment
	  storage with 'saveenv' and thus are persistent over restarts. nv variables
	  are coupled with global variables of the same name. Setting "nv.foo" results
	  in "global.foo" changed also (but not the other way round: setting "global.foo"
	  leaves "nv.foo" untouched). The idea is that nv variables can store defaults
	  while global variables can be changed during runtime without changing the
	  default.

menu "memory layout"

source "pbl/Kconfig"

config MMU
	bool "Enable MMU"
	depends on !CPU_ARM946E
	help
	  Saying yes here enables the MMU. This is useful on some architectures
	  to enable the data cache which depends on the MMU. See Documentation/mmu.txt
	  for further information.

config MMU_EARLY
	bool "Enable MMU early"
	depends on ARM
	depends on MMU
	default y
	help
	  This enables the MMU during early startup. This speeds up things during startup
	  of barebox, but may lead to harder to debug code. If unsure say yes here.

config HAVE_CONFIGURABLE_TEXT_BASE
	bool

config TEXT_BASE
	depends on HAVE_CONFIGURABLE_TEXT_BASE
	prompt "TEXT_BASE"
	hex
	default ARCH_TEXT_BASE
	help
	  The Address barebox gets linked at.

config BAREBOX_MAX_IMAGE_SIZE
	prompt "Maximum size of barebox"
	hex
	default 0xffffffff
	help
	  Define the maximum size of barebox

config BAREBOX_MAX_PBL_SIZE
	depends on PBL_IMAGE
	prompt "Maximum pre-bootloader size"
	hex
	default 0xffffffff
	help
	  On some hardware the ROM code can load the pbl into SRAM, but not
	  the whole image. This option specifies how big the pbl may get.

config BAREBOX_MAX_BARE_INIT_SIZE
	prompt "Maximum bare_init size"
	hex
	default 0xffffffff
	help
	  Define the maximum size of bare_init
	  this will allow your bare_init to fit in SRAM as example
	  ARCH can overwrite it via ARCH_BAREBOX_MAX_BARE_INIT_SIZE

config HAVE_CONFIGURABLE_MEMORY_LAYOUT
	bool

choice
	prompt "select memory layout"
	depends on HAVE_CONFIGURABLE_MEMORY_LAYOUT
	default MEMORY_LAYOUT_DEFAULT

config MEMORY_LAYOUT_DEFAULT
	bool "use default memory layout"
	help
	  select this option to use bareboxs standard memory layout:

	  stack
	  -----
	  malloc heap
	  -----
	  TEXT_BASE

config MEMORY_LAYOUT_FIXED
	bool "manually assign a memory layout"
	help
	  select this option to manually assign stack base and malloc
	  heap base

endchoice

config STACK_BASE
	depends on MEMORY_LAYOUT_FIXED
	hex
	prompt "STACK_BASE"

config STACK_SIZE
	hex
	default 0x8000
	prompt "Stack size"

config MALLOC_BASE
	depends on MEMORY_LAYOUT_FIXED
	hex
	prompt "MALLOC_BASE"

config MALLOC_SIZE
	hex
	default 0x400000
	prompt "malloc area size"
endmenu

config BROKEN
	bool

config EXPERIMENTAL
	bool
	prompt "Prompt for experimental code"

choice
	prompt "malloc implementation"

config MALLOC_DLMALLOC
	bool "dlmalloc"

config MALLOC_TLSF
	bool "tlsf"

config MALLOC_DUMMY
	bool "dummy malloc"
	depends on SHELL_NONE
	help
	  select this option to use a dummy malloc implementation. With this
	  memory is never freed. This is suitable for well tested noninteractive
	  environments only.

endchoice

config MODULES
	depends on HAS_MODULES
	depends on EXPERIMENTAL
	bool "module support"
	help
	  This option enables support for loadable modules via insmod. Module
	  support is quite experimental at the moment. There is no convenient
	  way to compile modules and the list of exported symbols to actually
	  make use of modules is short to nonexistent

config KALLSYMS
	depends on HAS_KALLSYMS
	bool "kallsyms"
	help
	  With Kallsyms enabled all symbols are compiled into the barebox image.
	  This is useful to print a nice backtrace when an exception occurs.

config RELOCATABLE
	depends on PPC || ARM
	bool "generate relocatable barebox binary"
	help
	  A non relocatable barebox binary will run at it's compiled in
	  link address in RAM. This leads to smaller image sizes but may
	  put barebox just in the middle of RAM. With this option enabled
	  instead barebox can determine this address at runtime and thus
	  allowing it to relocate to the end of the available RAM. This
	  way you have the whole memory in a single piece.

config PANIC_HANG
	bool "hang the system in case of a fatal error"
	help
	  This option enables stop of the system in case of a
	  fatal error, so that you have to reset it manually.
	  This is probably NOT a good idea for an embedded
	  system where you want the system to reboot
	  automatically as fast as possible, but it may be
	  useful during development since you can try to debug
	  the conditions that lead to the situation.

config PROMPT
	string
	prompt "barebox command prompt"
	default "barebox:"

config BAUDRATE
	int
	prompt "Default baudrate"
	default 115200

config SIMPLE_READLINE
	bool
	default y
	depends on !CMDLINE_EDITING

config CBSIZE
	int
	prompt "Buffer size for input from the Console"
	default 1024

config FIRMWARE
	bool

choice
	prompt "Select your shell"

	config SHELL_HUSH
		bool "hush parser"
		select ENVIRONMENT_VARIABLES
		select COMMAND_SUPPORT
		select PARAMETER
		select BINFMT
		select STDDEV
		help
		  Enable hush support. This is the most advanced shell available
		  for barebox.

	config SHELL_SIMPLE
		bool "Simple parser"
		select ENVIRONMENT_VARIABLES
		select COMMAND_SUPPORT
		select PARAMETER
		select STDDEV
		help
		  simple shell. No if/then, no return values from commands, no loops

	config SHELL_NONE
		bool "no shell (noninteractive build)"
		help
		  No shell at all. This means no shell is started and your board has
		  to overwrite the barebox_main function pointer which is then called
		  at the end of the barebox startup process.
endchoice

config MAXARGS
	int
	depends on SHELL_SIMPLE
	prompt "max. Number of arguments accepted for monitor commands"
	default 16

config GLOB
	bool
	select FNMATCH
	prompt "globbing support"
	help
	  If you want to use wildcards like * or ? say y here.

	  Globbing can be used in the HUSH shell, but is also used
	  internally in the menutree command.

config GLOB_SORT
	select QSORT
	bool
	prompt "glob sort support"
	depends on GLOB

config PROMPT_HUSH_PS2
	string
	depends on SHELL_HUSH
	prompt "hush PS2"
	default "> "

config HUSH_FANCY_PROMPT
	bool
	depends on SHELL_HUSH
	select PROCESS_ESCAPE_SEQUENCE
	prompt "allow fancy hush prompts"
	help
	  Allow to set PS1 from the command line. PS1 can have several escaped commands
	  like \h for the 'model' string or \w for the current working directory.

config CMDLINE_EDITING
	depends on !SHELL_NONE
	bool
	prompt "Enable command line editing"

config AUTO_COMPLETE
	bool
	depends on CMDLINE_EDITING
	prompt "Enable auto completion"

config MENU
	bool
	prompt "Menu Framework"
	depends on !SHELL_NONE
	select PROCESS_ESCAPE_SEQUENCE
	help
	  a menu framework that allow us to create list menu to simplify
	  barebox and make it more user-friendly

config PASSWORD
	bool
	prompt "Password Framework"
	select DIGEST
	help
	  allow you to have password protection framework

config PASSWORD_DEFAULT
	string
	prompt "Password default file"
	depends on PASSWORD
	help
	  Set this to a file which is used as default password file. This file
	  has to contain the passwd encoded with the selected password digest.
	  i.e.:
	  echo -ne "MyPassword" | md5sum | while read a b; do echo $a > passwdfile; done


if PASSWORD

choice
	prompt "passwd checksum"

config PASSWD_SUM_MD5
	bool "MD5"
	select DIGEST_MD5_GENERIC

config PASSWD_SUM_SHA1
	bool "SHA1"
	select DIGEST_SHA1_GENERIC

config PASSWD_SUM_SHA256
	bool "SHA256"
	select DIGEST_SHA256_GENERIC

config PASSWD_SUM_SHA512
	bool "SHA512"
	select DIGEST_SHA512_GENERIC

config PASSWD_CRYPTO_PBKDF2
	bool "PBKDF2"
	select CRYPTO_PBKDF2

endchoice

endif

config DYNAMIC_CRC_TABLE
	bool
	depends on CRC32
	prompt "Generate the crc32 table dynamically"
	default y
	help
	  Saying yes to this option saves around 800 bytes of binary size.
	  If unsure say yes.

config ERRNO_MESSAGES
	bool
	prompt "print error values as text"
	default y

config TIMESTAMP
	bool
	default y
	select GREGORIAN_CALENDER
	prompt "print timestamp information from images"
	help
	  When CONFIG_TIMESTAMP is selected, the timestamp
	  (date and time) of an image is printed by image
	  commands like bootm or iminfo. This option is
	  automatically enabled when you select CFG_CMD_DATE .

menuconfig BOOTM
	select UIMAGE
	default y if COMMAND_SUPPORT
	bool "bootm support"

config BOOTM_SHOW_TYPE
	bool
	depends on BOOTM
	prompt "show image information"
	help
	  Displays some tags from the uImage:

	  - OS type
	  - architecture,
	  - type
	  - compression method.

config BOOTM_VERBOSE
	bool
	prompt "verbose support"
	depends on BOOTM
	help
	  Adds the verbose (-v switch) command line option.

config BOOTM_INITRD
	bool
	prompt "initial RAM disk (initrd) support"
	depends on BOOTM
	help
	  Adds support for initial RAM disk and this two command line options:

	  -r INITRD  specify an initrd image
	  -L ADDR    specify initrd load address

config BOOTM_OFTREE
	bool
	depends on BOOTM
	select OFTREE
	prompt "device tree (oftree) support"
	help
	  Add support to pass a device tree (a.k.a Open Firmware Tree, oftree). Adds
	  this command line option:

	  -o DTS  specify device tree

config BOOTM_OFTREE_UIMAGE
	bool
	prompt "support passing device tree (oftree) uImages"
	depends on BOOTM_OFTREE
	help
	  Support using oftree uImages. Without this only raw oftree
	  blobs can be used.

config BOOTM_AIMAGE
	bool
	prompt "Android image support"
	depends on BOOTM && ARM
	help
	  Support using Android Images.

config BOOTM_FITIMAGE
	bool
	prompt "FIT image support"
	select FITIMAGE
	depends on BOOTM && ARM
	help
	  Support using Flattened Image Tree (FIT) Images. FIT is an image
	  format introduced by U-Boot. A FIT image contains one or multiple
	  kernels, device trees and initrds. The FIT image itself is a flattened
	  device tree binary. Have a look at the u-boot source tree
	  in the "doc/uImage.FIT" folder for more information:
	  http://git.denx.de/?p=u-boot.git;a=tree;f=doc/uImage.FIT

config BOOTM_FITIMAGE_SIGNATURE
	bool
	prompt "support verifying signed FIT images"
	depends on BOOTM_FITIMAGE
	select FITIMAGE_SIGNATURE
	help
	  Support verifying signed FIT images. This requires FIT images
	  as described in:
	  http://git.denx.de/?p=u-boot.git;a=blob;f=doc/uImage.FIT/signature.txt
	  Additionally the barebox device tree needs a /signature node with the
	  public key with which the image has been signed.

config BOOTM_FITIMAGE_PUBKEY
	string "Path to dtsi containing pubkey"
	default "../fit/pubkey.dtsi"
	depends on BOOTM_FITIMAGE_SIGNATURE
	help
	  Set Path to a dts snippet which holds the public keys for FIT images. The
	  snippet can then be included in a device tree with
	  "#include CONFIG_BOOTM_FITIMAGE_PUBKEY".

config BOOTM_FORCE_SIGNED_IMAGES
	bool
	prompt "Force booting of signed images"
	depends on BOOTM_FITIMAGE_SIGNATURE
	help
	  With this option enabled only signed images can be booted, unsigned images
	  are refused to boot. Effectively this means only FIT images can be booted
	  since they are the only supported image type that support signing.

config BOOTM_OPTEE
	bool
	prompt "support booting OP-TEE"
	depends on BOOTM && ARM
	help
	  OP-TEE is a trusted execution environment (TEE). With this option
	  enabled barebox supports starting optee_os as part of the bootm command.
	  Instead of the kernel bootm starts the optee_os binary which then starts
	  the kernel in nonsecure mode. Pass the optee_os binary with the -t option
	  or in the global.bootm.tee variable.

config BOOTM_OPTEE_SIZE
	hex
	default 0x02000000
	prompt "OP-TEE Memory Size"
	depends on BOOTM_OPTEE
	help
	  Size to reserve in main memory for OP-TEE.
	  Can be smaller than the actual size used by OP-TEE, this is used to prevent
	  barebox from allocating memory in this area.

config BLSPEC
	depends on FLEXIBLE_BOOTARGS
	depends on !SHELL_NONE
	select BOOT
	select BOOTM
	select OFTREE
	bool
	prompt "Support bootloader spec"
	help
	  Enable this to let barebox support the Freedesktop bootloader spec,
	  see: http://www.freedesktop.org/wiki/Specifications/BootLoaderSpec/
	  The bootloader spec is a standard interface between the bootloader
	  and the kernel. It allows the bootloader to discover boot options
	  on a device and it allows the Operating System to install / update
	  kernels.

config FLEXIBLE_BOOTARGS
	bool
	prompt "flexible Linux bootargs generation"
	depends on GLOBALVAR
	help
	  Select this to get a more flexible bootargs generation. With this
	  option the bootargs are concatenated together from global variables
	  beginning with 'global.linux.bootargs.' and 'global.linux.mtdparts.'
	  This allows for more flexible scripting since with it it's possible
	  to replace parts of the bootargs string without reconstructing it
	  completely.

config IMD
	bool "barebox metadata support"

config IMD_TARGET
	bool "build bareboximd target tool"
	depends on IMD
	depends on !SANDBOX

config KERNEL_INSTALL_TARGET
	bool
	depends on !SANDBOX
	prompt "Build kernel-install utility for the target"
	help
	  Enable this to compile the kernel-install script using the cross
	  compiler. The utility for the target will be under
	  scripts/kernel-install-target

choice
	prompt "console support"
	default CONSOLE_FULL

config CONSOLE_FULL
	bool
	prompt "full"
	help
	  This option enables full console support capable of
	  handling multiple consoles. Also the full console support
	  is able to store the output which comes before a console
	  is registered in a circular buffer which will be printed
	  once the first console is registered. Recommended for most
	  usecases.

config CONSOLE_SIMPLE
	bool
	prompt "simple"

config CONSOLE_NONE
	bool
	prompt "none"

endchoice

choice
	prompt "Console activation strategy"
	depends on CONSOLE_FULL
	default CONSOLE_ACTIVATE_FIRST

config CONSOLE_ACTIVATE_FIRST
	bool
	prompt "activate first console on startup"
	help
	  Normally on startup all consoles are disabled, so you won't
	  see anything from barebox starting. Enabling this option
	  enables the first console.

config CONSOLE_ACTIVATE_ALL
	bool
	prompt "activate all consoles on startup"
	help
	  Enabling this options activates all consoles on startup, so
	  you will get output and a prompt on all consoles simultaneously.
	  Only the first registered console will have the full startup
	  log though.

config CONSOLE_ACTIVATE_NONE
	prompt "leave all consoles disabled"
	bool
	help
	  Leave all consoles disabled on startup. Board code or environment
	  is responsible for enabling a console. Otherwise you'll get a working
	  barebox, you just won't see anything.

endchoice

config CONSOLE_ALLOW_COLOR
	prompt "Allow colored console output during boot"
	bool
	help
	  If enabled, colored output is allowed during boot. This is the
	  compile time default for colored console output. After boot it
	  can be controlled using global.allow_color.

config PBL_CONSOLE
	depends on PBL_IMAGE
	depends on !CONSOLE_NONE
	bool "Enable console support in PBL"
	help
	  This enables printf/pr_* support in the PBL to get more
	  informational output earlier during startup. Note that
	  printf/pr_* need a valid C environment, so the binary
	  must be running at the address it's linked at and bss must
	  be cleared. On ARM that would be after setup_c().

source "common/ratp/Kconfig"

config PARTITION
	bool
	prompt "Enable Partitions"

source "common/partitions/Kconfig"

config ENV_HANDLING
	select CRC32
	bool "Support environment files storage"
	default y if !SHELL_NONE
	help
	  Enabling this option will give you environment files which can be stored
	  over reboots. The "saveenv" command will store all files under /env/ to
	  the persistent environment, the "loadenv" command (also executed during
	  startup) will bring them back. If unsure, say yes.

config DEFAULT_ENVIRONMENT
	bool
	default y
	depends on ENV_HANDLING
	prompt "Compile in default environment"
	help
	  Enabling this option will give you a default environment when
	  the environment found in the environment sector is invalid

choice
	prompt "default compression for in-barebox binaries"
	default DEFAULT_COMPRESSION_NONE if PBL_IMAGE
	default DEFAULT_COMPRESSION_LZO if LZO_DECOMPRESS
	default DEFAULT_COMPRESSION_XZ if XZ_DECOMPRESS
	default DEFAULT_COMPRESSION_GZIP if ZLIB
	default DEFAULT_COMPRESSION_LZ4 if LZ4_DECOMPRESS
	default DEFAULT_COMPRESSION_BZIP2 if BZLIB
	help
	  Select the default compression for in-barebox binary files. Files
	  compiled into barebox like for example the default environment will
	  be compressed with this compression type.

config DEFAULT_COMPRESSION_GZIP
	bool "gzip"
	depends on ZLIB

config DEFAULT_COMPRESSION_BZIP2
	bool "bzip2"
	depends on BZLIB

config DEFAULT_COMPRESSION_LZO
	bool "lzo"
	depends on LZO_DECOMPRESS

config DEFAULT_COMPRESSION_LZ4
	bool "lz4"
	depends on LZ4_DECOMPRESS

config DEFAULT_COMPRESSION_XZ
	bool "xz"
	depends on XZ_DECOMPRESS

config DEFAULT_COMPRESSION_NONE
	bool "no compression"

endchoice

config DEFAULT_ENVIRONMENT_GENERIC_NEW
	bool "Generic environment template"
	depends on DEFAULT_ENVIRONMENT
	depends on SHELL_HUSH
	select BOOTM
	select COMMAND_SUPPORT
	select CMD_GETOPT
	select GLOB
	select GLOB_SORT
	select GLOBALVAR
	select CMD_GLOBAL
	select CMD_AUTOMOUNT
	select CMD_BASENAME
	select CMD_READLINK
	select CMD_DIRNAME
	select CMD_TEST
	select NVVAR
	select CMD_NV
	select FLEXIBLE_BOOTARGS
	select CMD_BOOT
	select NET_CMD_IFUP if NET
	select CMD_IP_ROUTE_GET if NET
	select CMD_HOST if NET

config DEFAULT_ENVIRONMENT_GENERIC
	bool "Generic environment template (old version)"
	depends on DEFAULT_ENVIRONMENT
	depends on !DEFAULT_ENVIRONMENT_GENERIC_NEW
	depends on SHELL_HUSH
	select COMMAND_SUPPORT
	select GLOBALVAR
	select CMD_GETOPT
	select CMD_CRC
	select CMD_CRC_CMP
	select CMD_GLOBAL
	help
	  With this option barebox will use the generic default
	  environment found under defaultenv/ in the src tree.
	  The Directory given with DEFAULT_ENVIRONMENT_PATH
	  will be added to the default environment. This should
	  at least contain a /env/config file.
	  This will be able to overwrite the files from defaultenv.

config DEFAULT_ENVIRONMENT_GENERIC_NEW_MENU
	bool
	depends on DEFAULT_ENVIRONMENT_GENERIC_NEW
	depends on CMD_MENUTREE
	default y

config DEFAULT_ENVIRONMENT_GENERIC_NEW_DFU
	bool
	depends on DEFAULT_ENVIRONMENT_GENERIC_NEW
	depends on USB_GADGET_DFU
	default y

config DEFAULT_ENVIRONMENT_PATH
	string
	depends on DEFAULT_ENVIRONMENT
	prompt "Default environment path"
	help
	  Space separated list of paths the default environment will be taken from.
	  Relative paths will be relative to the barebox Toplevel dir, but absolute
	  paths are fine aswell.

config BAREBOXENV_TARGET
	bool
	depends on !SANDBOX
	prompt "build bareboxenv tool for target"
	help
	  'bareboxenv' is a tool to access the barebox environment from a running Linux
	  system. Say yes here to build it for the target.

config BAREBOXCRC32_TARGET
	bool
	prompt "build bareboxcrc32 tool for target"
	depends on !SANDBOX
	help
	  'bareboxcrc32' is a userspacetool to generate the crc32 checksums the same way
	  barebox does. Say yes here to build it for the target.

config POLLER
	bool "generic polling infrastructure"

config STATE
	bool "generic state infrastructure"
	select CRC32
	select ENVIRONMENT_VARIABLES
	select OFTREE
	select PARAMETER

config STATE_CRYPTO
	bool "HMAC based authentication support"
	depends on STATE
	select CRYPTO_KEYSTORE
	select DIGEST
	select DIGEST_HMAC_GENERIC
	help
	  This options enables HMAC based authentication support for
	  the state's header and data. This means the state framework
	  can verify both the data integrity and the authentication of
	  the state's header and data.

	  Don't forget to select a hash algorithm in the
	  crypto/digests menu.

	  See Documentation/devicetree/bindings/barebox/barebox,state.rst
	  for more information.

config STATE_BACKWARD_COMPATIBLE
	bool "backward compatible 'direct storage backend'"
	depends on STATE
	help
	  With this option enabled the 'direct' storage backend keeps backward
	  compatibility with older revisions of the state framework. Newer
	  revisions expect an additional 'meta header' and fail otherwise.

config BOOTCHOOSER
	bool "bootchooser infrastructure"
	select BOOT
	select BOOTM
	select ENVIRONMENT_VARIABLES
	select OFTREE
	select PARAMETER

config RESET_SOURCE
	bool "detect Reset cause"
	depends on GLOBALVAR
	help
	  Provide a global variable at runtine which reflects the possible cause
	  of the reset and why the bootloader is currently running. It can be
	  useful for any kind of system recovery or repair.

config MACHINE_ID
	bool "pass machine-id to kernel"
	depends on FLEXIBLE_BOOTARGS
	depends on SHA1
	help
	  Sets the linux.bootargs.machine_id global variable with a value of
	  systemd.machine_id=UID. The UID is a persistent device-specific
	  id. It is a hash over device-specific information provided by various
	  sources.

	  Note: if multiple sources provide hashable device-specific information
	  (via machine_id_set_hashable()) the information provided by the last call
	  prior to the late initcall set_machine_id() is used to generate the
	  machine id from. Thus when updating barebox the machine id might change.

	  Note: if no hashable information is available no machine id will be passed
	  to the kernel.

endmenu

menu "Debugging"

config COMPILE_LOGLEVEL
	int "compile loglevel"
	default 6
	help
	  This defines the maximum loglevel compiled into the binary. Less important
	  messages will be compiled away resulting in a smaller binary.

	  0    system is unusable (emerg)
	  1    action must be taken immediately (alert)
	  2    critical conditions (crit)
	  3    error conditions (err)
	  4    warning conditions (warn)
	  5    normal but significant condition (notice)
	  6    informational (info)
	  7    debug-level messages (debug)
	  8    verbose debug messages (vdebug)

config DEFAULT_LOGLEVEL
	int "default loglevel"
	default 7
	help
	  This defines the default runtime loglevel. It can be changed using the
	  global.loglevel variable. Available logelevels are:

	  0    system is unusable (emerg)
	  1    action must be taken immediately (alert)
	  2    critical conditions (crit)
	  3    error conditions (err)
	  4    warning conditions (warn)
	  5    normal but significant condition (notice)
	  6    informational (info)
	  7    debug-level messages (debug)
	  8    verbose debug messages (vdebug)

config DEBUG_LL
	bool
	depends on HAS_DEBUG_LL
	prompt "Low level debug messages (read help)"
	help
	  Enable this to get low level debug messages during barebox
	  initialization. This is helpful if you are debugging code that
	  executes before the console is initialized.

	  This requires SoC specific support. Most SoCs require the
	  debug UART to be initialized by a debugger or first stage
	  bootloader.

	  Note that selecting this option will limit barebox to a single
	  UART definition, as specified below under "low-level debugging
	  port". Attempting to boot the resulting image on a different
	  platform *will not work*, so this option should not be enabled
	  for builds that are intended to be portable.

choice
	prompt "Kernel low-level debugging port"
	depends on DEBUG_LL

config DEBUG_IMX1_UART
	bool "i.MX1 Debug UART"
	depends on ARCH_IMX1
	help
	  Say Y here if you want kernel low-level debugging support
	  on i.MX1.

config DEBUG_IMX21_UART
	bool "i.MX21 Debug UART"
	depends on ARCH_IMX21
	help
	  Say Y here if you want kernel low-level debugging support
	  on i.MX21.

config DEBUG_IMX25_UART
	bool "i.MX25 Debug UART"
	depends on ARCH_IMX25
	help
	  Say Y here if you want kernel low-level debugging support
	  on i.MX25.

config DEBUG_IMX27_UART
	bool "i.MX27 Debug UART"
	depends on ARCH_IMX27
	help
	  Say Y here if you want kernel low-level debugging support
	  on i.MX27.

config DEBUG_IMX31_UART
	bool "i.MX31 Debug UART"
	depends on ARCH_IMX31
	help
	  Say Y here if you want kernel low-level debugging support
	  on i.MX31.

config DEBUG_IMX35_UART
	bool "i.MX35 Debug UART"
	depends on ARCH_IMX35
	help
	  Say Y here if you want kernel low-level debugging support
	  on i.MX35.

config DEBUG_IMX50_UART
	bool "i.MX50 Debug UART"
	depends on ARCH_IMX50
	help
	  Say Y here if you want kernel low-level debugging support
	  on i.MX50.

config DEBUG_IMX51_UART
	bool "i.MX51 Debug UART"
	depends on ARCH_IMX51
	help
	  Say Y here if you want kernel low-level debugging support
	  on i.MX51.

config DEBUG_IMX53_UART
	bool "i.MX53 Debug UART"
	depends on ARCH_IMX53
	help
	  Say Y here if you want kernel low-level debugging support
	  on i.MX53.

config DEBUG_IMX6Q_UART
	bool "i.MX6Q Debug UART"
	depends on ARCH_IMX6
	help
	  Say Y here if you want kernel low-level debugging support
	  on i.MX6Q.

config DEBUG_IMX7D_UART
	bool "i.MX7D Debug UART"
	depends on ARCH_IMX7
	help
	  Say Y here if you want barebox low-level debugging support
	  on i.MX7D.

config DEBUG_IMX8MQ_UART
	bool "i.MX8MQ Debug UART"
	depends on ARCH_IMX8MQ
	help
	  Say Y here if you want barebox low-level debugging support
	  on i.MX8MQ.

config DEBUG_VF610_UART
	bool "VF610 Debug UART"
	depends on ARCH_VF610
	help
	  Say Y here if you want kernel low-level debugging support
	  on VF610.

config DEBUG_OMAP3_UART
	bool "OMAP3 Debug UART"
	depends on ARCH_OMAP3
	help
	  Say Y here if you want kernel low-level debugging support
	  on OMAP3.

config DEBUG_OMAP4_UART
	bool "OMAP4 Debug UART"
	depends on ARCH_OMAP4
	help
	  Say Y here if you want kernel low-level debugging support
	  on OMAP4.

config DEBUG_AM33XX_UART
	bool "AM33XX Debug UART"
	depends on ARCH_AM33XX
	help
	  Say Y here if you want kernel low-level debugging support
	  on AM33XX.

config DEBUG_ROCKCHIP_UART
	bool "RK3xxx Debug UART"
	depends on ARCH_ROCKCHIP
	help
	  Say Y here if you want kernel low-level debugging support
	  on RK3XXX.

config DEBUG_SOCFPGA_UART0
	bool "Use SOCFPGA UART0 for low-level debug"
	depends on ARCH_SOCFPGA
	help
	  Say Y here if you want kernel low-level debugging support
	  on SOCFPGA(Cyclone 5 and Arria 5) based platforms.

config DEBUG_SOCFPGA_UART1
	bool "Use SOCFPGA UART1 for low-level debug"
	depends on ARCH_SOCFPGA
	help
	  Say Y here if you want kernel low-level debugging support
	  on SOCFPGA(Arria 10) based platforms.

config DEBUG_RPI1_UART
	bool "RaspberryPi 1 PL011 UART"
	depends on ARCH_BCM283X
	help
	  Say Y here if you want low-level debugging support on
	  RaspberryPi 1 boards.

config DEBUG_AT91_UART
	bool "AT91 Debug UART"
	depends on ARCH_AT91
	help
	  Say Y here if you want barebox low-level debugging support
	  on AT91 based platforms.

config DEBUG_RPI2_3_UART
	bool "RaspberryPi 2/3 PL011 UART"
	depends on ARCH_BCM283X
	help
	  Say Y here if you want low-level debugging support on
	  RaspberryPi 2 and 3 boards.

config DEBUG_RPI3_MINI_UART
	bool "RaspberryPi 3 mini UART"
	depends on ARCH_BCM283X
	help
	  Say Y here if you want low-level debugging support on
	  RaspberryPi 3 board mini UART.
endchoice

config DEBUG_IMX_UART_PORT
	int "i.MX Debug UART Port Selection" if DEBUG_IMX1_UART || \
						DEBUG_IMX21_UART || \
						DEBUG_IMX25_UART || \
						DEBUG_IMX27_UART || \
						DEBUG_IMX31_UART || \
						DEBUG_IMX35_UART || \
						DEBUG_IMX51_UART || \
						DEBUG_IMX53_UART || \
						DEBUG_IMX6Q_UART || \
						DEBUG_IMX6SL_UART || \
						DEBUG_IMX7D_UART || \
						DEBUG_IMX8MQ_UART || \
						DEBUG_VF610_UART
	default 1
	depends on ARCH_IMX
	help
	  Choose UART port on which kernel low-level debug messages
	  should be output.

config DEBUG_OMAP_UART_PORT
	int "OMAP Debug UART Port Selection" if DEBUG_OMAP3_UART || \
						DEBUG_OMAP4_UART || \
						DEBUG_AM33XX_UART
	default 1
	depends on ARCH_OMAP
	help
	  Choose UART port on which kernel low-level debug messages
	  should be output. Possible values are:
	  OMAP3: 1 - 3
	  OMAP4: 1 - 3
	  AM33XX: 0 - 2

config DEBUG_ROCKCHIP_UART_PORT
	int "RK3xxx UART debug port" if DEBUG_ROCKCHIP_UART
	default 2
	depends on ARCH_ROCKCHIP
	help
	  Choose UART port on which kernel low-level debug messages
	  should be output.

config DEBUG_SOCFPGA_UART_PHYS_ADDR
	hex "Physical base address of debug UART" if DEBUG_LL
	default 0xffc02000 if DEBUG_SOCFPGA_UART0
	default 0xffc02100 if DEBUG_SOCFPGA_UART1
	depends on ARCH_SOCFPGA

config DEBUG_SOCFPGA_UART_CLOCK
	int "SoCFPGA UART debug clock" if DEBUG_LL
	default 100000000 if ARCH_SOCFPGA_CYCLONE5
	default  50000000 if ARCH_SOCFPGA_ARRIA10
	depends on ARCH_SOCFPGA
	help
	  Choose UART root clock.


config DEBUG_LAYERSCAPE_UART_PORT
	int "Layerscape UART port selection"
	depends on ARCH_LAYERSCAPE
	default 1
	help
	  Select the UART port number used for early debugging here. Port
	  numbers start counting from 1.

config DEBUG_AT91_UART_BASE
	hex "AT91 Debug UART Port Selection" if DEBUG_AT91_UART
	default 0xfffff200 if SOC_AT91RM9200  || SOC_AT91SAM9260 \
	                   || SOC_AT91SAM9261 || SOC_AT91SAM9X5  \
			   || SOC_AT91SAM9N12
	default 0xffffee00 if SOC_AT91SAM9263 || SOC_AT91SAM9G45 || ARCH_SAMA5D3
	default 0xfc069000 if ARCH_SAMA5D4
	default 0xfffff200
	depends on ARCH_AT91
	help
	  Specify UART port base address on which barebox low-level
	  debug messages should be output.

config DEBUG_INITCALLS
	bool "Trace initcalls"
	help
	  If enabled this will print initcall traces.


config PBL_BREAK
	bool "Execute software break on pbl start"
	depends on ARM
	help
	  If this enabled, barebox will be compiled with BKPT instruction
	  on early pbl init. This option should be used only with JTAG debugger!

source "lib/Kconfig.ubsan"

config KASAN
	bool "KASAN: runtime memory debugger"
	depends on HAVE_ARCH_KASAN
	help
	  Enables KASAN (KernelAddressSANitizer) - runtime memory debugger,
	  designed to find out-of-bounds accesses and use-after-free bugs.

endmenu

config HAS_DEBUG_LL
	bool

config DDR_SPD
	bool
	select CRC_ITU_T

config HAVE_ARCH_KASAN
	bool
